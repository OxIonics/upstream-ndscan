r"""This package contains abstractions for the data source of a plot, and several
implementations thereof.

This is a fairly thin layer above the results (meta)data generated by experiments,
addressing two main points:

 * We want to use the same type of plot (1D/2D/…) in several different contexts – not
   only as the top-level scan while an experiment is running, but also to display
   subscans, or for displaying ARTIQ HDF5 files after the fact.
 * The data we want to show is dynamic: new data points come in over time as an
   experiment is running, fits are recomputed, the user might select a different
   point to display a subscan for, and so on. We want to react to those changes, yet
   avoid re-creating the entire hierarchy of plot objects on every update to keep the
   user interface responsive.

To achieve this, the data for a given plot is represented as a tree of ``QObject``\ s
that emit signals when their direct children changed in a specific way (e.g.
``channel_schemata_changed``, ``points_appended``, …).

(This is somewhat of an ad-hoc solution which works well since the described data model
is fairly small in complexity; a more principled approach for creating models with
different granularities of change tracking might be more appropriate for more complex
situations.)
"""

import dataclasses
import logging
import numpy
from qasync import QtCore
from typing import Any, Callable, Dict, List, Optional
from .online_analysis import OnlineNamedFitAnalysis
from ...import interfaces
from .. annotations import interface_to_analysis

logger = logging.getLogger(__name__)


class Context(QtCore.QObject):
    """Describes the environment in which a certain plot is displayed.

    This is the moral equivalent of a container for global variables and should be used
    only sparsely (i.e. for actual properties of the environment).
    """

    source_id_changed = QtCore.pyqtSignal(str)
    title_changed = QtCore.pyqtSignal(str)

    def __init__(self, set_dataset: Callable[[str, Any], None] = None):
        super().__init__()
        self._set_dataset = set_dataset
        self._title = ""
        self._source_id = "<unknown>"

    def get_title(self) -> str:
        return self._title

    def set_title(self, title: str) -> None:
        if self._title != title:
            self._title = title
            self.title_changed.emit(title)

    def get_source_id(self):
        """Return a short string that helps the user to identify the data source.

        This is usually based on the run id, and shown in plots for data traceability
        purposes.
        """
        return self._source_id

    def set_source_id(self, source_id):
        if self._source_id != source_id:
            self._source_id = source_id
            self.source_id_changed.emit(source_id)

    def is_online_master(self) -> bool:
        """Return whether the plot is run in an environment where there is a connection
        to an ARTIQ master (as opposed to e.g. displaying an offline results file).
        """
        return self._set_dataset is not None

    def set_dataset(self, key: str, value: Any) -> None:
        """Sets dataset ``key`` to ``value`` on the connected master, if any.

        See: :meth:`is_online_master`.
        """
        self._set_dataset(key, value)


class AnnotationDataSource(QtCore.QObject):
    changed = QtCore.pyqtSignal()

    def get(self) -> Any:
        raise NotImplementedError


class FixedDataSource(AnnotationDataSource):
    def __init__(self, value):
        super().__init__()
        self._value = value

    def get(self) -> Any:
        return self._value

    def set(self, value: Any) -> None:
        # Values could be NumPy arrays, so since NumPy blatantly disregards the Python
        # object model and does not return a bool-ish value (but an array of bools),
        # need to use array_equal().
        if numpy.array_equal(value, self._value):
            return
        self._value = value
        self.changed.emit()


class OnlineAnalysisDataSource(AnnotationDataSource):
    def __init__(self, analysis, key):
        super().__init__()
        self._analysis = analysis
        self._analysis.updated.connect(self.changed)
        self._key = key

    def get(self) -> Any:
        return self._analysis.get_data().get(self._key, None)


@dataclasses.dataclass
class Annotation(interfaces.annotations.AnnotationInterface):
    pass

class Root(QtCore.QObject):
    """The root of a plot data tree, i.e. all the data making up a plot displayed in a
    given window.

    This is a reference to (at most) one :class:`Model`, but makes it possible to
    represent situations where the model is not yet known (e.g. because we are still
    waiting for the experiment to set the top-level metadata datasets), or might change
    (because we are showing a subscan for a user-selected point).
    """

    model_changed = QtCore.pyqtSignal(object)

    def get_model(self) -> Optional["Model"]:
        raise NotImplementedError


class Model(QtCore.QObject):
    channel_schemata_changed = QtCore.pyqtSignal(dict)

    def __init__(self, schema_revision: int, context: Context):
        super().__init__()
        self.context = context
        self.schema_revision = schema_revision

    def get_channel_schemata(self) -> Dict[str, Any]:
        raise NotImplementedError


class SinglePointModel(Model):
    point_changed = QtCore.pyqtSignal(object)

    def get_point(self) -> Optional[Dict[str, Any]]:
        raise NotImplementedError


class ScanModel(Model):
    points_rewritten = QtCore.pyqtSignal(dict)
    points_appended = QtCore.pyqtSignal(dict)
    annotations_changed = QtCore.pyqtSignal(list)

    def __init__(self, axes: List[Dict[str, Any]], schema_revision: int,
                 context: Context):
        super().__init__(schema_revision, context)
        self.axes = axes
        self._annotations = []  # INTERFACES TODO: type annotation
        # INTERFACES TODO: removed _annotation_schemata
        self._online_analyses = {}

    def get_point_data(self) -> Dict[str, Any]:
        raise NotImplementedError

    def get_annotations(self) -> List[Annotation]:
        return self._annotations

    def get_analysis_result_source(self, name: str) -> Optional[AnnotationDataSource]:
        raise NotImplementedError

    #
    # TODO: Having these as elaborate implementation in the base class leaves a bit of a
    # bad aftertaste, although it's slightly hard to qualify why it should be bad
    # design.
    #

    # INTERACES TODO: changed from _set_annotation_schemata
    # This function used to do two things: decode the annotations and rebind the
    # data sources. I've split these into a pair of functions
    def _decode_annotations(self, descriptions: List[Dict[str, Any]]):
        self._annotations = []
        for desc in descriptions:
            # INTERFACES TODO: applet-side decoder!
            annotation = interfaces.utils.decode(desc)
            assert isinstance(annotation, interfaces.annotations.AnnotationInterface)
            self._annotations.append(interface_to_analysis(annotation))

        self._rebind_annotation_data_sources()

    def _rebind_annotation_data_sources(self):
        """Replace annotations with ones created according to the given schemata.

        This will be called by concrete subclasses once/whenever they have received the
        annotation metadata.
        """

        def data_source(source_desc):
            # INTERFACES TODO this should not be a dict!
            # WHAT KIND OF OBJECT SHOULD THIS BE?
            # SOME SHOULD BE IN THE INITIAL DECODE...
            # THIS SHOULD MOVE INTO A MEMBER FUNCTION of the applet-side interface
            # to allow for custom data sources
            data_source = interfaces.utils.decode(source_desc)
            if not isinstance(data_source, interfaces.annotations.AnnotationDataSourceInterface):
                raise ValueError(f"Expected an annotation data source, got a {data_souce.interface_type}")

            # THIS CODE should move into plots.annotations into a from_interface func
            # or merge the interface classes with the annotation items classes
            if isinstance(data_source, interfaces.annotations.FixedDataSourceInterface):
                return FixedDataSource(data_source.value)

            if isinstance(data_source, interfaces.annotations.OnlineResultDataSourceInterface):
                analysis = self._online_analyses.get(data_source.analysis_name, None)
                if analysis is None:
                    return None
                return OnlineAnalysisDataSource(analysis, data_source.result_key)
            if isinstance(data_sorce, AnalysisResultSourceInterface):
                source = self.get_analysis_result_source(data_source.name)
                if source is None:
                    logger.info("Analysis result data source not found: %s", data_source.name)
                return source

            logger.info("Ignoring unsupported annotation data source type: '%s'", data_source.interface_subtype)
            assert 0  # INTERFACES TODO: should not be reached
            return None

        for idx, annotation in enumerate(self._annotations):
            annotation.data = {k: data_source(v) for k, v in annotation.data.items()}
            if hasattr(annotation, "channels"):
                annotation.data = {k: data_source(v) for k, v in annotation.channels.items()}

            # if any(s is None for t in bound_sources for s in t.values()):
                # logger.warning("Ignoring analysis, not all data found: %s", annotation)
                # continue

        print("REBOUND SOURCES")
        for annotation in self._annotations:
            import pprint
            pprint.pprint(annotation.data)
        print(">....")
        self.annotations_changed.emit(self._annotations)

    def _set_online_analyses(self, analysis_schemata: Dict[str, Dict[str,
                                                                     Any]]) -> None:
        """Create and hook up online analyses from the given schema.

        This will be called by concrete subclasses once/whenever they have received
        the schema metadata.
        """
        for a in self._online_analyses.values():
            a.stop()
        self._online_analyses = {}

        for name, schema in analysis_schemata.items():
            kind = schema["kind"]
            if kind == "named_fit":
                self._online_analyses[name] = OnlineNamedFitAnalysis(schema, self)
            else:
                logger.warning("Ignoring unsupported online analysis type: '%s'", kind)

        self._rebind_annotation_data_sources()
